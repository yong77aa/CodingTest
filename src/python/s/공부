* DFS, BFS 란?
DFS : Stack, 재귀 함수를 사용해 depth 기준 탐색 - 한 루트를 반복함
BFS : Queue, While 문을 사용해 breadth 기준 탐색 - 한 노드에서 갈 수 있는 모든 노드를 탐색함

* DFS, BFS의 선택 기준은?
DFS: 모든 경우를 하나하나 전부 탐색해야 하는 완전탐색 문제 (조합, 순열, ..)
BFS: 깊이 특징을 이용한 문제 (최단경로, ..)
반복문이 재귀함수보다 빠르게 동작하는 경우가 많기 때문에 DFS, BFS 둘 다 활용 가능한 경우 BFS를 사용하는 것이 시간적으로 이득

* Queue 생성
from collections import deque
queue = deque([list])

* 공백 제거
rstrip: 오른쪽 공백 제거
lstrip: 왼쪽 공백 제거
strip: 왼쪽 오른쪽 공백 제거

* 리스트 for문 한줄에 작성
[결과 for 반복문]
ex) [list(stdin.readline()) for _ in range(n)]: 결과를 반복해 리스트 생성

* 리스트 for문 인덱스와 값 한번에 접근하기
for index, val in enumerate(arr):

* if not
if not x: x가 False, 0, 빈 리스트, 빈 튜플, 빈 딕셔너리, "", None, 등등 인 경우 True 반환

* 문자열 입력 관련
import sys
sys.stdin.readline().rstrip()

* 파이썬의 얕은 복사와 깊은 복사
얕은 복사: a를 변경하면 b도 변경됨 (같은 메모리 주소를 바라보고 있음), copy 메소드도 얕은 복사에 해당함
깊은 복사: a를 변경해도 b는 변경되지 않음 -> copy.deepcopy를 사용함

* 반복문 range
range(a1, a2, a3) 인 경우
a1: 시작범위 (0은 생략가능)
a2: 마지막 범위 (지정된 숫자 바로앞까지 실행)
a3: 간격 (생략하면 기본 값 1)

* 빈 배열 만들기
arr = [0 for _ in range(n)]: 일차원 배열
arr = [[0] * n for _ in range(n)]: 이차원 배열

* 내림, 반올림, 올림
내림: math.floor() (무조껀 내림), math.trunc() (0까지만 내림)
반올림: math.round()
올림: math.ceil()

* min, max 함수
인자 1개: 매개변수로 들어온 인자 내부의 가장 큰 값
인자 2개: 매개변수로 들어온 반복이 가능한 인자 중 가장 큰 데이터 반환

* 좌표 4방위 이동 (동, 서, 북, 남)
x: [1, -1, 0, 0]
y: [0, 0, -1, 1]

* 동적 프로그래밍
큰 문제를 작은 단위로 풀어나가는 방법론
작은 문제의 값을 저장했다가 큰 문제를 해결할 때 해당 값을 재사용함 (가장 이득이 되는 조건을 선택)
탑다운, 보텀업 2가지 방법으로 구현 가능함